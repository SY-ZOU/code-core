## 计算机补码运算

加法和减法这两个完全相反的东西怎么能用同一方法计算呢？

截取了一段0-999的数轴，因为这个自创的数轴是圆的，所以999加1就会变成0而不是1000，这样不就实现了加上一个数还能变小了嘛。

> 694-246=448
>
> 那么用补码运算法就应该先寻找要减去的这个数的补码，补码为：1000-246=754
>
> 把减去246转成加上246的补码：694+754=1448
>
> 因为超过了最大能表示的数999，所以取余数：1448-1000=448

在二进制中

> 随便找一个数10110010求补码：100000000-10110010=01001110
>
> 100000000可以看成11111111加1，也就是说上面求补码的过程可以转换成：
>
> 11111111+1-10110010 = 11111111-10110010+1=01001101+1 = 01001110
>
> 这个减法有点特殊，被减数是11111111，我们只要把减数里的1全部换成0，0全部换成1就行了。过程叫做取反，得到的结果叫做反码。因为被减数减了1，所以结果要加上1，这就是为什么书上总是说补码的求法是取反加一。通过这个方法就可以不借助减法也能求补了，多亏了几百年前莱布尼茨发明了这种神奇的计数进制.

但是，处理负数问题时

> 300-700=-400
>
> 1000-700=300，然后将减法转换成加法：300+300=600
>
> **仔细一看，600不是正好可以理解为-400的补码吗！**他得到的不是结果本身，而是结果的补码。

**所有的数都应该用补码来表示，正数的补码是它自身，而负数的补码是取反后加一。**

> 100+300=400，200-800=-600，200+200=400。
>
> 400是-600的补码，答案并没有任何问题，但是这是在知道正确答案的情况下我们可以理解计算得到的答案。如果不知道正确答案仅仅得到计算的答案400，它到底是400的原码，还是-600的补码呢？

我们规定每个二进制数的第一位为符号位，0为正数1为负数。而后面的所有位都是数值位，和原来的表示方法一样。这样的话我们无论看到什么数都先检查它的第一位确定它的符号，这样就知道该如何解读它。

**当减法的结果为正数，计算过程会发生溢出，并且答案就是原码本身。当结果为负数，则不会发生溢出，但是我们只能得到答案的补码，需要进行求补运算才能得到正确答案。**

### （1）运算规则

- 所有的数都以补码的形式保存，正数的补码是它自身，负数的补码为绝对值取反加一
- 每一个数前面都要加上一个符号位，0表示正数，1表示负数。
- 减去一个数可以转换成加上求补之后的减数。

> 补码和求补是两回事，补码表示的是一种存储数据的方法，而求补是一种运算，千万不能弄混。
>
> 对于计算机来说，加上一个正数和减去一个负数的运算原理不同。前一种情况可以直接相加，而后一种情况需要对减数进行求补然后相加，多了一个运算步骤。

### （2）加法

机器数相加的补码可以先通过分别对两个机器数求补码，然后再相加得到，在采用补码形式表示时，进行加法运算可以把符号位和数值位一起进行运算(若符号位有进位，导致了益出，则直接舍弃)，结果为两数之和的补码形式。

### （3）减法

减法实际上就是加一个负数。运算法则和加法实际上是一致的！